---
title: "Boost Future의 continuations(연속 연결)"
date: 2020-11-08T23:31:17+09:00
#Dev, C++
categories:
- Language
- C++
tags:
- C++
- Future
- Boost
- Modern C++
keywords:
- tech
- developer
- 개발자
- programmer
- programming
- software
- 프로그래머
- coding
- 코딩
- server

#thumbnailImage: //example.com/image.jpg
---

비동기 프로그래밍에서 하나의 비동기 작업이 완료되면 두 번째 작업을 호출하고 여기에 데이터를 전달하는 것이 매우 일반적입니다. 현재 C ++ 표준은 future에 대한 연속 등록을 허용하지 않습니다. 를 사용하면 결과를 기다리는 대신 결과가 준비되면 호출되는 비동기 작업에 연속 작업이 "연결"됩니다. then 함수를 사용하여 등록 된 연속 futue는 대기를 차단하거나 폴링 스레드를 낭비하지 않도록하여 애플리케이션의 응답 성과 확장 성을 크게 향상시킵니다

<!--more-->





`future.then()`은 하나를 다른 것의 연속이라고 선언하여 두 개의 futue를 순차적으로 구성하는 기능을 제공합니다. 

아래 예에서는 멤버 함수 사용의 연속으로 등록됩니다 . 이 작업은 준비 후 어떻게 진행해야하는지 설명하는 람다 함수를 사용 합니다 .

```cpp
#include <boost/thread/future.hpp>
using namespace boost;
int main()
{
  future<int> f1 = async([]() { return 123; });
  future<string> f2 = f1.then([](future<int> f) { return f.get().to_string(); // here .get() won't block });
}
```





이 함수의 핵심 기능 중 하나는 여러 비동기 작업을 연결하는 기능입니다. 비동기 프로그래밍에서는 각 연속 작업이 이전 작업이 완료 될 때만 실행되는 일련의 작업을 정의하는 것이 일반적입니다. 어떤 경우에는 선행 future가 연속이 입력으로 받아들이는 값을 생성합니다. `future.then()`을 사용 하면 연속 체인을 만드는 것이 간단하고 직관적이됩니다.

```cpp
myFuture.then(...).then(...).then(...).
```





입력 매개 변수 :

- Lambda 함수 : 고려할 수있는 한 가지 옵션은 성공을위한 기능과 오류 처리를위한 기능의 두 가지를 취하는 것입니다. 람다 함수는 예외를 전달하는 입력으로 future를 사용합니다. 이는 예외 전파를 간단하게 만듭니다. 이 접근 방식은 또한 연속 연결을 단순화합니다.
- 스케줄러 : 스케줄러 참조를 가져 오기 위해에 오버로드를 제공 하면 프로그래머의 손에있는 미래의 실행에 대해 큰 유연성을 제공합니다. 위에서 설명한 것처럼 종종 시작 정책을 취하는 것만으로는 강력한 비동기 작업에 충분하지 않습니다. 스케줄러의 수명은 연결된 future들 보다 길어야합니다. 
- 시작 정책 : 스케줄러가 제공하는 추가 유연성이 필요하지 않은 경우.





반환 값 : future를 반환하도록 하는 것은 여러 연속을 연결하는 기능에 기반 합니다. 이러한 구성 가능의 이점은 프로그래머에게 코드에 대한 놀라운 제어와 유연성을 제공합니다. a 가 아닌 객체를 반환하는 것도 훨씬 저렴한 작업이므로 성능이 향상됩니다. 객체는 체인 기능을 활용할 필요가 없습니다. 또한 future :: share ()를 사용하여 필요할 때 a 에서 a 로 쉽게 이동할 수 있습니다.





### 결론

std::future에는 없는 기능으로 then을 활용 할 경우 블락이 걸리지 않기 때문에 서버 성능에 이점이 있고 비동기 코드 작성시 유연성을 제공합니다.(비동기 A 작업이 완료되고 처리 할 비동기 B 작업의 명시)